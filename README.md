# SP_LB2-1_2-5

Лабораторная работа №2-1 
Вариант №3
Тема: 
 УПРАВЛЕНИЕ ПРОЦЕССАМИ В WIN32 API
Цели лабораторной работы:
 Изучение вопросов управления процессами в WIN API. Получение практических навыков разработки приложений, выполняющих запуск дочерних процессов, управление процессами, получение информации о процессах. Получение навыков организации взаимодействия процессов и создания многопроцессных комплексов.

Задание:
 Изучить управление процессами в Win32 API. 
Приобрести практические навыки применения функций Win32 API для управления процессами в Windows-приложении и обеспечения взаимодействия процессов. 
В качестве практической части работы необходимо создать приложение, которое будет обеспечивать создание дочерних процессов c запуском приложений Notepad.exe, Notepad.exe с открытием указанного файла, Calc.exe, собственного приложения. Для дочерних процессов необходимо предусмотреть возможность получения и отображения различной информации состояния.

 Выполнение: 
1. В своей рабочей папке создайте проект типа Win32 Application: 
Создайте типовой проект с главным окном или воспользуйтесь проектом предыдущей работы по диалоговым окнам. 
Выполните компиляцию, компоновку и запустите программу на выполнение. Убедитесь в работоспособности программы. 

2. Добавлены в приложение код и ресурсы для создания дочерних процессов: 
а) меню “Процессы” с командами “Блокнот”, “Блокнот с текстом”, “Калькулятор”, “Закрыть Блокнот”; 
б) меню “Информация о процессах” с командами “Текущий процесс(0)”, “Блокнот (1)”, “Блокнот с текстом (2)”, “Калькулятор (3)”. 
Созданы глобальные массивы: 
HANDLE ProcHandle[5] для дескрипторов процессов; 
DWORD ProcId[5] для идентификаторов процессов; 
HANDLE ThreadHandle[5] для дескрипторов потоков; 
DWORD ThreadId[5] для .идентификаторов потоков; 
LPTSTR ProcImage[5] для указателей строк, идентифицирущих файлы запускаемых программ; 
TCHAR CmdParam[5][260] для строк c параметрами запускаемых программ. 
HANDLE  ProcHandle[5] = { NULL };        // Дескрипторы процессов
DWORD ProcId[5] = { 0 };                // Идентификаторы процессов (PID)
HANDLE ThreadHandle[5] = { NULL };      // Дескрипторы основных потоков
DWORD ThreadId[5] = { 0 };              // Идентификаторы потоков (TID)
LPTSTR ProcImage[5] = { NULL };         // Пути к исполняемым файлам
TCHAR CmdParam[5][260] = { {0} };       // Параметры командной строки

2.3 Изменения в коде программы 
Добавьте в приложение код обработки новых команд меню с выполнением следующих действий: 
а) Запуск приложения «Блокнот». 
б) Запуск приложения «Блокнот» с загрузкой текстового документа. 
в) Запуск программы Calc.exe. 
г) Завершение приложения «Блокнот».

3. Добавьте в приложение ресурсы и код для получения информации состояния дочерних процессов 
 
4. Выполните эксперименты с полученной программой: 
4.1 Создать процесс 1 и просмотреть информацию о нем. Закрыть запущенный Блокнот и просмотреть информацию о процессе 1; 
4.2 Создать процесс 2 и просмотреть информацию о нем. 
4.3 Закрыть Блокнот с текстом файла Test.txt. Посмотреть информацию о процессе 2. Запустить снова процесс 2.
4.4 Создать процесс 3 и просмотреть информацию о нем. 
4.5 Выполнить команду “Закрыть Блокнот” и просмотреть информацию о процессе 
Сравнивать получаемые данные о процессах с информацией программы Process Viewer из пакета инструментальных средств Microsoft Visual Studio и программы «Process Explorer». 

Дать пояснения к полученной информации. Пояснить причину ошибки при выполнении пункта 4.1. 

if (found) {
    // Сброс информации о процессе Блокнота (индекс 1)
    if (ProcHandle[1]) {
        CloseHandle(ProcHandle[1]);  // Закрываем дескриптор
        ProcHandle[1] = NULL;        // Устанавливаем в NULL  
    }
    ProcId[1] = 0;                   // Обнуляем PID   НЕ ПРОИСХОДИТ!
    ThreadId[1] = 0;                 // Обнуляем TID   НЕ ПРОИСХОДИТ!
}
После закрытия Блокнота через функцию FindAndCloseNotepad(), дескриптор процесса ProcHandle[1] закрывается и устанавливается в NULL, но идентификаторы ProcId[1] и ThreadId[1] остаются прежними.

5. Задание по самостоятельной работе: 
5.1 Модифицируйте подпункт б) пункта 2.3 таким образом, чтобы можно было выбирать любой текстовый файл для загрузки в блокнот; 

5.2 Создайте свое приложение с именем TestProc. Добавьте в приложение SP_LB2-1 команду меню TestProc и обеспечте запуск приложения TestProc с возможностью управления размерами, положением и режимом отображения его главного окна (используйте структуру STARTUPINFO в родительском процессе); 
 
5.3 Создайте приложение запускающее блокнот с открытием текстового файла, ожиданием пока пользователь закроет блокнот и последующим выводом содержимого текстового файла. 

https://github.com/Maxevgen555/SP_LB2-1_2-5
При работе использовались ии-агенты https://chat.deepseek.com/  https://www.perplexity.ai/ и copilot (встроенный клиент VS2024, отдельно установленная программа).

Вывод: 

 Я изучил управление процессами в Win32 API, получил практические навыки применения функций Win32 API для управления процессами в Windows-приложении и обеспечения взаимодействия процессов создал приложение, которое обеспечивает создание дочерних процессов c запуском приложений Notepad.exe, Notepad.exe с открытием указанного файла, Calc.exe, собственного приложения. 






Лабораторная работа №2-2 
Вариант №3
Тема: 
 УПРАВЛЕНИЕ ПОТОКАМИ В WIN32 API
Цели лабораторной работы:
 Изучить возможности управление потоками в Win32 API. Приобрести практические навыки создания многопоточных приложений Windows.

Задание:
 	Изучить представленные в папке работы примеры многопоточных приложений и реализованные в них возможности управление потоками в Win32 API. Приобрести практические навыки создания многопоточных приложений Windows.

 Выполнение: 
    	1. В своей рабочей папке создайте проект типа Win32 Application с главным окном, меню и диалоговым окном “О программе …”. Дайте проекту имя “ФАМИЛИЯ_thread_lb” .
 
2. Добавьте PopUp меню “Поток 1” и “Поток 2” с командами “Создать поток”, “Создать ждущий поток”, “Приостановить поток”, “Продолжить работу потока”, “Уничтожить поток”, “Увеличить приоритет”, “Уменьшить приоритет”.
Добавьте PopUp меню “Информация о потоках” с командами “Первичный поток ”, “Поток 1”, “Поток 2”.
 
3. Добавьте в приложение код обработки новых команд меню “Поток 1”, “Поток 2” и "Информация о потоках". Команды в меню “Поток 1”, “Поток 2” одинаковые, но для разных потоков.
3.1 .По команде “Создать поток” создавать вторичный поток, функция которого будет выводить в бесконечном цикле “бегущую” строку “Вторичный поток создал <Фамилия>”. Строку выводить в главное окно начиная с задаваемой позиции. Количество созданных вторичных потоков хранить в глобальной переменной g_uThCount. При создании нового потока сохранять дескриптор потока в массиве hSecThread под соответствующим индексом(0 для первичного, 1 для “Поток 1”, 2 для “Поток 2”). Аналогичным образом сохранять идентификаторы потоков в массиве dwSecThreadId. Перед выполнением команды проверять существование соответствующего потока. 
DWORD WINAPI ThreadFunc1(LPVOID lpParam)
{
    HWND hWnd = (HWND)lpParam;  // Получаем дескриптор главного окна из параметра
    HDC hdc;                    // Контекст устройства для рисования
    RECT rect;                  // Прямоугольник для хранения размеров клиентской области
    TCHAR szMsg[] = _T("Вторичный поток 1 создал Гончаров"); // Текст для отображения

    // Бесконечный цикл потока (завершается принудительно)
    while (TRUE)
    {
        // Проверяем состояние потока - рисуем только если поток активен
        if (threadStates[1] == 1) // Если поток активен
        {
            hdc = GetDC(hWnd);  // Получаем контекст устройства для рисования
            if (hdc)
            {
                GetClientRect(hWnd, &rect);  // Получаем размеры клиентской области окна

                // Очистка предыдущей позиции текста (затираем старый текст)
                SetBkColor(hdc, GetSysColor(COLOR_WINDOW));     // Цвет фона = цвет окна
                SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT)); // Цвет текста = стандартный
                TextOut(hdc, thread1Pos - 1, 50, _T(""), 0);    // Затираем старый текст

                // Вывод нового текста
                SetBkColor(hdc, RGB(255, 255, 0));  // Желтый фон
                SetTextColor(hdc, RGB(0, 0, 255));  // Синий текст
                TextOut(hdc, thread1Pos, 50, szMsg, _tcslen(szMsg));  // Рисуем текст

                ReleaseDC(hWnd, hdc);  // Освобождаем контекст устройства
            }

            thread1Pos += 5;  // Перемещаем позицию текста
            if (thread1Pos > rect.right)  // Если текст ушел за правую границу
                thread1Pos = -300;        // Возвращаем в начало (с запасом для плавности)
        }

        Sleep(100);  // Задержка для контроля скорости движения
    }

    return 0;  // Код завершения (никогда не выполняется из-за бесконечного цикла)
}
 
3.2. По команде “Создать ждущий поток” создать вторичный поток аналогично, как в пункте 3.1, но находящийся сразу после создания в “спящем” состоянии. Поток не создавать если он уже создан по этой же команде меню или по команде "Создать поток"
 
3.3. По команде “Приостановить поток” перевести поток в состояние ожидания (сделать “спящим”).
3.4. По команде “Продолжить работу потока ” перевести поток в рабочее состояние (“разбудить поток”).
3.5. По команде “Уничтожить поток ” завершить работу потока.
3.6. По команде “Увеличить приоритет” увеличить относительный приоритет потока.
3.7. По команде “Уменьшить приоритет” уменьшить относительный приоритет потока.
 
Для меню "Информация о потоках"
3.8. По команде “Информация о потоках” -> “Поток хх” в диалоговом окне в элемент типа список выводить информацию о соответствующем потоке (включая и первичный поток). Для каждого потока выводить:
3.8.1. Идентификатор потока;
3.8.2. Дескриптор потока;
3.8.3. Состояние потока (активное, ожидание, завершен(код завершения));
3.8.4. Относительный приоритет потока;
3.8.5. Время работы потока с момента его создания.
 
 Добавьте в приложение поток, который будет обеспечивать вывод анимированного изображения в соответствии с индивидуальным заданием.
 
Коды программ и краткое описание лабораторных работ на GitHub:
https://github.com/Maxevgen555/SP_LB2-1_2-5
При работе использовались ии-агенты https://chat.deepseek.com/  https://www.perplexity.ai/ и copilot (встроенный клиент VS2024, отдельно установленная программа).





Лабораторная работа №2-3 
Вариант №3
Тема: 
 СИНХРОНИЗАЦИЯ ВЗАИМОДЕЙСТВУЮЩИХ ПОТОКОВ 
В WIN32 API

Цели лабораторной работы:
 	Изучить возможности согласования работы взаимодействующих потоков с целью исключения гонок и обеспечения необходимой последовательности их выполнения, а так же используемые для этой цели системные средства. Приобрести практические навыки синхронизации работы потоков и создания безопасных, с точки зрения многопоточности, приложений Windows.

Задание:
  	Изучить представленные в папке работы примеры многопоточных приложений и реализованные в них возможности синхронизации работы. Разработать собственные безопасные с точки зрения многопоточности приложения в соответствии с индивидуальными заданиями.
Выполнение: 
Получение практических навыков синхронизации потоков: 
1. Используйте проект предыдущей лабораторной работы 2-2. 
2. Добавьте PopUp меню “Синхронизация” с командами “Включить согласование”, “Выключить согласование”. 
  POPUP "&Синхронизация"
    BEGIN
        MENUITEM "Включить согласование", IDM_SYNC_ENABLE
        MENUITEM "Выключить согласование", IDM_SYNC_DISABLE
    END
3. Добавьте в приложение код обработки новых команд меню и средства синхронизации работы в соответствии с индивидуальным заданием 1. 
void EnableSynchronization()
{
    g_synchronizationEnabled = TRUE;  // Установка флага синхронизации

    // Принудительное обновление окна для отображения изменений
    HWND hWnd = FindWindow(szClassName, NULL);
    if (hWnd) InvalidateRect(hWnd, NULL, TRUE);

    // Информационное сообщение пользователю
    MessageBox(NULL, _T("Синхронизация включена\nКаждый поток будет выполнять N шагов атомарно"),
        _T("Синхронизация"), MB_OK | MB_ICONINFORMATION);
}

// Выключение синхронизации потоков
void DisableSynchronization()
{
    g_synchronizationEnabled = FALSE;  // Сброс флага синхронизации

    // Принудительное обновление окна
    HWND hWnd = FindWindow(szClassName, NULL);
    if (hWnd) InvalidateRect(hWnd, NULL, TRUE);

    // Информационное сообщение пользователю
    MessageBox(NULL, _T("Синхронизация выключена\nПотоки работают параллельно"),
        _T("Синхронизация"), MB_OK | MB_ICONINFORMATION);
}
… 
            // Команды синхронизации
        case IDM_SYNC_ENABLE:  // Включить синхронизацию
            EnableSynchronization();
            break;
        case IDM_SYNC_DISABLE:  // Выключить синхронизацию
            DisableSynchronization();
            break;
…
TCHAR syncInfo[256];
 if (g_synchronizationEnabled)  // Если синхронизация включена
 {
     SetTextColor(hdc, RGB(0, 128, 0));  // Зеленый текст
     _stprintf(syncInfo, _T("✓ СИНХРОНИЗАЦИЯ ВКЛЮЧЕНА (Режим К16: N = %d шагов)"),
         4 * _tcslen(g_thread1Text));
 }
 else  // Если синхронизация выключена
 {
     SetTextColor(hdc, RGB(200, 0, 0));  // Красный текст
     _tcscpy(syncInfo, _T("✗ СИНХРОНИЗАЦИЯ ВЫКЛЮЧЕНА (Параллельный режим)"));
 }
 TextOut(hdc, 20, 155, syncInfo, _tcslen(syncInfo));

 // ОТОБРАЖЕНИЕ СЧЕТЧИКОВ ШАГОВ ПОТОКОВ
 SetTextColor(hdc, RGB(0, 0, 128));  // Темно-синий текст
 TCHAR counterInfo[256];
 _stprintf(counterInfo, _T("Поток 1: %d шагов  |  Поток 2: %d шагов  |  Всего: %d шагов"),
     g_stepCounter[1], g_stepCounter[2], g_stepCounter[1] + g_stepCounter[2]);
 TextOut(hdc, 20, 175, counterInfo, _tcslen(counterInfo));

 // ОТОБРАЖЕНИЕ СТАТУСОВ ПОТОКОВ
 SetTextColor(hdc, RGB(80, 80, 80));  // Серый текст
 TCHAR statusInfo[256];
 _stprintf(statusInfo, _T("Статус: Поток1-%s | Поток2-%s | Анимация-%s"),
     hSecThread[1] ? (threadStates[1] == 1 ? _T("Активен") : _T("Приостановлен")) : _T("Не создан"),
     hSecThread[2] ? (threadStates[2] == 1 ? _T("Активен") : _T("Приостановлен")) : _T("Не создан"),
     hAnimationThread ? (animationState == 1 ? _T("Активна") : _T("Приостановлена")) : _T("Не создана"));
 TextOut(hdc, 20, 195, statusInfo, _tcslen(statusInfo));

 // ВОССТАНОВЛЕНИЕ ИСХОДНОГО ШРИФТА И УДАЛЕНИЕ СОЗДАННОГО
 SelectObject(hdc, hOldFont);
 DeleteObject(hFont);

 EndPaint(hWnd, &ps);  // Завершение перерисовки
… 

4. Выполните компиляцию, компоновку и отладку программы. 
5. Выполните тестирование добавленных функций ( работа с синхронизацией и без).  
 
При включении синхронизации потоки выполняются попеременно, заданный промежуток времени.
6. Создайте и протестируйте приложение с применением для синхронизации объекта «ожидающий таймер» (WaitableTimer Object) в соответствии с индивидуальным заданием 2.  	
POPUP "&Таймер"
BEGIN
    MENUITEM "Создать ждущий таймер", IDM_TIMER_CREATE
    MENUITEM "Запустить таймер", IDM_TIMER_START
    MENUITEM "Остановить таймер", IDM_TIMER_STOP
    MENUITEM "Информация о таймере", IDM_TIMER_INFO
END

// Таймер
#define IDM_TIMER_CREATE 1601
#define IDM_TIMER_START 1602
#define IDM_TIMER_STOP 1603
#define IDM_TIMER_INFO 1604

// ==================== ФУНКЦИИ ДЛЯ WAITABLE TIMER (ВАРИАНТ Т3) ====================

// Создание ждущего таймера
void CreateWaitableTimer()
{
    if (hWaitableTimer != NULL)
    {
        MessageBox(NULL, _T("Таймер уже создан!"), _T("Ошибка"), MB_OK | MB_ICONWARNING);
        return;
    }

    // Создание ждущего таймера
    hWaitableTimer = CreateWaitableTimer(NULL, FALSE, NULL);
    if (hWaitableTimer)
    {
        MessageBox(NULL, _T("Ждущий таймер создан успешно!"), _T("Таймер"), MB_OK | MB_ICONINFORMATION);
    }
    else
    {
        MessageBox(NULL, _T("Ошибка создания таймера!"), _T("Ошибка"), MB_OK | MB_ICONERROR);
    }
}

// Запуск таймера
void StartWaitableTimer()
{
    if (hWaitableTimer == NULL)
    {
        MessageBox(NULL, _T("Сначала создайте таймер!"), _T("Ошибка"), MB_OK | MB_ICONWARNING);
        return;
    }

    if (g_timerEnabled)
    {
        MessageBox(NULL, _T("Таймер уже запущен!"), _T("Ошибка"), MB_OK | MB_ICONWARNING);
        return;
    }

    LARGE_INTEGER liDueTime;
    const int nTimerUnitsPerSecond = 10000000; // 100-наносекундные интервалы в секунде

    // Установка времени первого срабатывания: через 15 секунд
    liDueTime.QuadPart = -(15 * nTimerUnitsPerSecond);

    // Установка таймера: первый сигнал через 15 секунд, затем каждые 15 секунд
    if (SetWaitableTimer(hWaitableTimer, &liDueTime, 15 * 1000, NULL, NULL, FALSE))
    {
        g_timerEnabled = TRUE;
        g_timerCounter = 0;

        // Создание потока для обработки таймера
        HANDLE hTimerThread = CreateThread(NULL, 0, TimerThreadProc, NULL, 0, NULL);
        if (hTimerThread)
        {
            CloseHandle(hTimerThread); // Закрываем дескриптор, так как он нам не нужен
        }

        MessageBox(NULL, _T("Таймер запущен!\nКаждые 15 секунд будет появляться MessageBox."), 
                   _T("Таймер"), MB_OK | MB_ICONINFORMATION);
    }
    else
    {
        MessageBox(NULL, _T("Ошибка запуска таймера!"), _T("Ошибка"), MB_OK | MB_ICONERROR);
    }
}

// Остановка таймера
void StopWaitableTimer()
{
    if (hWaitableTimer && g_timerEnabled)
    {
        // Отмена таймера
        CancelWaitableTimer(hWaitableTimer);
        g_timerEnabled = FALSE;
        MessageBox(NULL, _T("Таймер остановлен!"), _T("Таймер"), MB_OK | MB_ICONINFORMATION);
    }
    else
    {
        MessageBox(NULL, _T("Таймер не активен!"), _T("Ошибка"), MB_OK | MB_ICONWARNING);
    }
}

// Функция потока для обработки таймера
DWORD WINAPI TimerThreadProc(LPVOID lpParam)
{
    while (g_timerEnabled)
    {
        // Ожидание сигнала от таймера с таймаутом 15 секунд
        DWORD dwResult = WaitForSingleObject(hWaitableTimer, 15000);

        if (dwResult == WAIT_OBJECT_0) // Таймер сработал
        {
            // Таймер сработал - показываем MessageBox
            ShowTimerMessageBox();
        }
        else if (dwResult == WAIT_TIMEOUT) // Таймаут 15 секунд
        {
            // Если ответ задерживается более 15 секунд - считаем это как RETRY
            g_timerCounter++;
            // Можно добавить логирование или другие действия
        }
        else if (dwResult == WAIT_ABANDONED) // Объект abandoned
        {
            break; // Выход из цикла
        }

        // Проверка флага на каждой итерации
        if (!g_timerEnabled)
            break;
    }
    return 0;
}

// Показать MessageBox с выбором действия
void ShowTimerMessageBox()
{
    g_timerCounter++; // Увеличиваем счетчик вызовов

    // Формирование текста сообщения
    TCHAR message[256];
    _stprintf(message, _T("Вызов номер %d\n\nПродолжить - RETRY\nЗавершить работу - ABORT"), g_timerCounter);

    // Показ MessageBox с таймаутом 15 секунд
    int result = MessageBox(NULL, message, _T("Ждущий таймер Т3"), 
                           MB_ABORTRETRYIGNORE | MB_ICONQUESTION | MB_DEFBUTTON1);

    // Обработка результата
    switch (result)
    {
    case IDABORT: // Завершить работу
        MessageBox(NULL, _T("Работа приложения завершается по запросу пользователя."), 
                   _T("Завершение"), MB_OK | MB_ICONINFORMATION);
        PostQuitMessage(0); // Завершение приложения
        break;

    case IDRETRY: // Продолжить
    case IDIGNORE: // Игнорировать (тоже продолжаем)
        // Просто продолжаем работу
        break;

    default:
        // Любой другой случай (например, закрытие крестиком) - продолжаем
        break;
    }
}
 
Коды программ и краткое описание лабораторных работ на GitHub:
https://github.com/Maxevgen555/SP_LB2-1_2-5
При работе использовались ии-агенты https://chat.deepseek.com/  https://www.perplexity.ai/ и copilot (встроенный клиент VS2024, отдельно установленная программа).

Вывод: 
В ходе выполнения лабораторной работы я изучил возможности согласования работы взаимодействующих потоков с целью исключения гонок и обеспечения необходимой последовательности их выполнения, а так же используемые для этой цели системные средства, представленные в папке работы примеры многопоточных приложений и реализованные в них возможности синхронизации работы. Разработал собственные, безопасные с точки зрения многопоточности, приложения в соответствии с индивидуальными заданиями.

Вывод: 
В ходе выполнения лабораторной работы я изучил возможности управления потоками в Win32 API, приобрел практические навыки создания многопоточных приложений Windows.





Лабораторная работа №2-4 
Вариант №3
Тема: 
 Разработка и применение динамически загружаемых библиотек 
в Win32 приложения

Цели лабораторной работы:
Изучить технологию создания и использования динамически загружаемых библиотек в WIN32 API.



