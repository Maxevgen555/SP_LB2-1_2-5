# SP_LB2-1_2-5

Лабораторная работа №2-1 
Вариант №3
Тема: 
 УПРАВЛЕНИЕ ПРОЦЕССАМИ В WIN32 API
Цели лабораторной работы:
 Изучение вопросов управления процессами в WIN API. Получение практических навыков разработки приложений, выполняющих запуск дочерних процессов, управление процессами, получение информации о процессах. Получение навыков организации взаимодействия процессов и создания многопроцессных комплексов.

Задание:
 Изучить управление процессами в Win32 API. 
Приобрести практические навыки применения функций Win32 API для управления процессами в Windows-приложении и обеспечения взаимодействия процессов. 
В качестве практической части работы необходимо создать приложение, которое будет обеспечивать создание дочерних процессов c запуском приложений Notepad.exe, Notepad.exe с открытием указанного файла, Calc.exe, собственного приложения. Для дочерних процессов необходимо предусмотреть возможность получения и отображения различной информации состояния.

 Выполнение: 
1. В своей рабочей папке создайте проект типа Win32 Application: 
Создайте типовой проект с главным окном или воспользуйтесь проектом предыдущей работы по диалоговым окнам. 
Выполните компиляцию, компоновку и запустите программу на выполнение. Убедитесь в работоспособности программы. 

2. Добавлены в приложение код и ресурсы для создания дочерних процессов: 
а) меню “Процессы” с командами “Блокнот”, “Блокнот с текстом”, “Калькулятор”, “Закрыть Блокнот”; 
б) меню “Информация о процессах” с командами “Текущий процесс(0)”, “Блокнот (1)”, “Блокнот с текстом (2)”, “Калькулятор (3)”. 
Созданы глобальные массивы: 
HANDLE ProcHandle[5] для дескрипторов процессов; 
DWORD ProcId[5] для идентификаторов процессов; 
HANDLE ThreadHandle[5] для дескрипторов потоков; 
DWORD ThreadId[5] для .идентификаторов потоков; 
LPTSTR ProcImage[5] для указателей строк, идентифицирущих файлы запускаемых программ; 
TCHAR CmdParam[5][260] для строк c параметрами запускаемых программ. 
HANDLE  ProcHandle[5] = { NULL };        // Дескрипторы процессов
DWORD ProcId[5] = { 0 };                // Идентификаторы процессов (PID)
HANDLE ThreadHandle[5] = { NULL };      // Дескрипторы основных потоков
DWORD ThreadId[5] = { 0 };              // Идентификаторы потоков (TID)
LPTSTR ProcImage[5] = { NULL };         // Пути к исполняемым файлам
TCHAR CmdParam[5][260] = { {0} };       // Параметры командной строки

2.3 Изменения в коде программы 
Добавьте в приложение код обработки новых команд меню с выполнением следующих действий: 
а) Запуск приложения «Блокнот». 
б) Запуск приложения «Блокнот» с загрузкой текстового документа. 
в) Запуск программы Calc.exe. 
г) Завершение приложения «Блокнот».

3. Добавьте в приложение ресурсы и код для получения информации состояния дочерних процессов 
 
4. Выполните эксперименты с полученной программой: 
4.1 Создать процесс 1 и просмотреть информацию о нем. Закрыть запущенный Блокнот и просмотреть информацию о процессе 1; 
4.2 Создать процесс 2 и просмотреть информацию о нем. 
4.3 Закрыть Блокнот с текстом файла Test.txt. Посмотреть информацию о процессе 2. Запустить снова процесс 2.
4.4 Создать процесс 3 и просмотреть информацию о нем. 
4.5 Выполнить команду “Закрыть Блокнот” и просмотреть информацию о процессе 
Сравнивать получаемые данные о процессах с информацией программы Process Viewer из пакета инструментальных средств Microsoft Visual Studio и программы «Process Explorer». 

Дать пояснения к полученной информации. Пояснить причину ошибки при выполнении пункта 4.1. 

if (found) {
    // Сброс информации о процессе Блокнота (индекс 1)
    if (ProcHandle[1]) {
        CloseHandle(ProcHandle[1]);  // Закрываем дескриптор
        ProcHandle[1] = NULL;        // Устанавливаем в NULL  
    }
    ProcId[1] = 0;                   // Обнуляем PID   НЕ ПРОИСХОДИТ!
    ThreadId[1] = 0;                 // Обнуляем TID   НЕ ПРОИСХОДИТ!
}
После закрытия Блокнота через функцию FindAndCloseNotepad(), дескриптор процесса ProcHandle[1] закрывается и устанавливается в NULL, но идентификаторы ProcId[1] и ThreadId[1] остаются прежними.

5. Задание по самостоятельной работе: 
5.1 Модифицируйте подпункт б) пункта 2.3 таким образом, чтобы можно было выбирать любой текстовый файл для загрузки в блокнот; 

5.2 Создайте свое приложение с именем TestProc. Добавьте в приложение SP_LB2-1 команду меню TestProc и обеспечте запуск приложения TestProc с возможностью управления размерами, положением и режимом отображения его главного окна (используйте структуру STARTUPINFO в родительском процессе); 
 
5.3 Создайте приложение запускающее блокнот с открытием текстового файла, ожиданием пока пользователь закроет блокнот и последующим выводом содержимого текстового файла. 

https://github.com/Maxevgen555/SP_LB2-1_2-5
При работе использовались ии-агенты https://chat.deepseek.com/  https://www.perplexity.ai/ и copilot (встроенный клиент VS2024, отдельно установленная программа).

Вывод: 

 Я изучил управление процессами в Win32 API, получил практические навыки применения функций Win32 API для управления процессами в Windows-приложении и обеспечения взаимодействия процессов создал приложение, которое обеспечивает создание дочерних процессов c запуском приложений Notepad.exe, Notepad.exe с открытием указанного файла, Calc.exe, собственного приложения. 






Лабораторная работа №2-2 
Вариант №3
Тема: 
 УПРАВЛЕНИЕ ПОТОКАМИ В WIN32 API
Цели лабораторной работы:
 Изучить возможности управление потоками в Win32 API. Приобрести практические навыки создания многопоточных приложений Windows.

Задание:
 	Изучить представленные в папке работы примеры многопоточных приложений и реализованные в них возможности управление потоками в Win32 API. Приобрести практические навыки создания многопоточных приложений Windows.

 Выполнение: 
    	1. В своей рабочей папке создайте проект типа Win32 Application с главным окном, меню и диалоговым окном “О программе …”. Дайте проекту имя “ФАМИЛИЯ_thread_lb” .
 
2. Добавьте PopUp меню “Поток 1” и “Поток 2” с командами “Создать поток”, “Создать ждущий поток”, “Приостановить поток”, “Продолжить работу потока”, “Уничтожить поток”, “Увеличить приоритет”, “Уменьшить приоритет”.
Добавьте PopUp меню “Информация о потоках” с командами “Первичный поток ”, “Поток 1”, “Поток 2”.
 
3. Добавьте в приложение код обработки новых команд меню “Поток 1”, “Поток 2” и "Информация о потоках". Команды в меню “Поток 1”, “Поток 2” одинаковые, но для разных потоков.
3.1 .По команде “Создать поток” создавать вторичный поток, функция которого будет выводить в бесконечном цикле “бегущую” строку “Вторичный поток создал <Фамилия>”. Строку выводить в главное окно начиная с задаваемой позиции. Количество созданных вторичных потоков хранить в глобальной переменной g_uThCount. При создании нового потока сохранять дескриптор потока в массиве hSecThread под соответствующим индексом(0 для первичного, 1 для “Поток 1”, 2 для “Поток 2”). Аналогичным образом сохранять идентификаторы потоков в массиве dwSecThreadId. Перед выполнением команды проверять существование соответствующего потока. 
DWORD WINAPI ThreadFunc1(LPVOID lpParam)
{
    HWND hWnd = (HWND)lpParam;  // Получаем дескриптор главного окна из параметра
    HDC hdc;                    // Контекст устройства для рисования
    RECT rect;                  // Прямоугольник для хранения размеров клиентской области
    TCHAR szMsg[] = _T("Вторичный поток 1 создал Гончаров"); // Текст для отображения

    // Бесконечный цикл потока (завершается принудительно)
    while (TRUE)
    {
        // Проверяем состояние потока - рисуем только если поток активен
        if (threadStates[1] == 1) // Если поток активен
        {
            hdc = GetDC(hWnd);  // Получаем контекст устройства для рисования
            if (hdc)
            {
                GetClientRect(hWnd, &rect);  // Получаем размеры клиентской области окна

                // Очистка предыдущей позиции текста (затираем старый текст)
                SetBkColor(hdc, GetSysColor(COLOR_WINDOW));     // Цвет фона = цвет окна
                SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT)); // Цвет текста = стандартный
                TextOut(hdc, thread1Pos - 1, 50, _T(""), 0);    // Затираем старый текст

                // Вывод нового текста
                SetBkColor(hdc, RGB(255, 255, 0));  // Желтый фон
                SetTextColor(hdc, RGB(0, 0, 255));  // Синий текст
                TextOut(hdc, thread1Pos, 50, szMsg, _tcslen(szMsg));  // Рисуем текст

                ReleaseDC(hWnd, hdc);  // Освобождаем контекст устройства
            }

            thread1Pos += 5;  // Перемещаем позицию текста
            if (thread1Pos > rect.right)  // Если текст ушел за правую границу
                thread1Pos = -300;        // Возвращаем в начало (с запасом для плавности)
        }

        Sleep(100);  // Задержка для контроля скорости движения
    }

    return 0;  // Код завершения (никогда не выполняется из-за бесконечного цикла)
}
 
3.2. По команде “Создать ждущий поток” создать вторичный поток аналогично, как в пункте 3.1, но находящийся сразу после создания в “спящем” состоянии. Поток не создавать если он уже создан по этой же команде меню или по команде "Создать поток"
 
3.3. По команде “Приостановить поток” перевести поток в состояние ожидания (сделать “спящим”).
3.4. По команде “Продолжить работу потока ” перевести поток в рабочее состояние (“разбудить поток”).
3.5. По команде “Уничтожить поток ” завершить работу потока.
3.6. По команде “Увеличить приоритет” увеличить относительный приоритет потока.
3.7. По команде “Уменьшить приоритет” уменьшить относительный приоритет потока.
 
Для меню "Информация о потоках"
3.8. По команде “Информация о потоках” -> “Поток хх” в диалоговом окне в элемент типа список выводить информацию о соответствующем потоке (включая и первичный поток). Для каждого потока выводить:
3.8.1. Идентификатор потока;
3.8.2. Дескриптор потока;
3.8.3. Состояние потока (активное, ожидание, завершен(код завершения));
3.8.4. Относительный приоритет потока;
3.8.5. Время работы потока с момента его создания.
 
 Добавьте в приложение поток, который будет обеспечивать вывод анимированного изображения в соответствии с индивидуальным заданием.
 
Коды программ и краткое описание лабораторных работ на GitHub:
https://github.com/Maxevgen555/SP_LB2-1_2-5
При работе использовались ии-агенты https://chat.deepseek.com/  https://www.perplexity.ai/ и copilot (встроенный клиент VS2024, отдельно установленная программа).





Лабораторная работа №2-3 
Вариант №3
Тема: 
 СИНХРОНИЗАЦИЯ ВЗАИМОДЕЙСТВУЮЩИХ ПОТОКОВ 
В WIN32 API

Цели лабораторной работы:
 	Изучить возможности согласования работы взаимодействующих потоков с целью исключения гонок и обеспечения необходимой последовательности их выполнения, а так же используемые для этой цели системные средства. Приобрести практические навыки синхронизации работы потоков и создания безопасных, с точки зрения многопоточности, приложений Windows.

Задание:
  	Изучить представленные в папке работы примеры многопоточных приложений и реализованные в них возможности синхронизации работы. Разработать собственные безопасные с точки зрения многопоточности приложения в соответствии с индивидуальными заданиями.





Вывод: 
В ходе выполнения лабораторной работы я изучил возможности управления потоками в Win32 API, приобрел практические навыки создания многопоточных приложений Windows.
