# SP_LB2-1_2-5

Лабораторная работа №2-1 
Вариант №3
Тема: 
 УПРАВЛЕНИЕ ПРОЦЕССАМИ В WIN32 API
Цели лабораторной работы:
 Изучение вопросов управления процессами в WIN API. Получение практических навыков разработки приложений, выполняющих запуск дочерних процессов, управление процессами, получение информации о процессах. Получение навыков организации взаимодействия процессов и создания многопроцессных комплексов.

Задание:
 Изучить управление процессами в Win32 API. 
Приобрести практические навыки применения функций Win32 API для управления процессами в Windows-приложении и обеспечения взаимодействия процессов. 
В качестве практической части работы необходимо создать приложение, которое будет обеспечивать создание дочерних процессов c запуском приложений Notepad.exe, Notepad.exe с открытием указанного файла, Calc.exe, собственного приложения. Для дочерних процессов необходимо предусмотреть возможность получения и отображения различной информации состояния.

 Выполнение: 
1. В своей рабочей папке создайте проект типа Win32 Application: 
Создайте типовой проект с главным окном или воспользуйтесь проектом предыдущей работы по диалоговым окнам. 
Выполните компиляцию, компоновку и запустите программу на выполнение. Убедитесь в работоспособности программы. 

2. Добавлены в приложение код и ресурсы для создания дочерних процессов: 
а) меню “Процессы” с командами “Блокнот”, “Блокнот с текстом”, “Калькулятор”, “Закрыть Блокнот”; 
б) меню “Информация о процессах” с командами “Текущий процесс(0)”, “Блокнот (1)”, “Блокнот с текстом (2)”, “Калькулятор (3)”. 
Созданы глобальные массивы: 
HANDLE ProcHandle[5] для дескрипторов процессов; 
DWORD ProcId[5] для идентификаторов процессов; 
HANDLE ThreadHandle[5] для дескрипторов потоков; 
DWORD ThreadId[5] для .идентификаторов потоков; 
LPTSTR ProcImage[5] для указателей строк, идентифицирущих файлы запускаемых программ; 
TCHAR CmdParam[5][260] для строк c параметрами запускаемых программ. 
HANDLE  ProcHandle[5] = { NULL };        // Дескрипторы процессов
DWORD ProcId[5] = { 0 };                // Идентификаторы процессов (PID)
HANDLE ThreadHandle[5] = { NULL };      // Дескрипторы основных потоков
DWORD ThreadId[5] = { 0 };              // Идентификаторы потоков (TID)
LPTSTR ProcImage[5] = { NULL };         // Пути к исполняемым файлам
TCHAR CmdParam[5][260] = { {0} };       // Параметры командной строки

2.3 Изменения в коде программы 
Добавьте в приложение код обработки новых команд меню с выполнением следующих действий: 
а) Запуск приложения «Блокнот». 
б) Запуск приложения «Блокнот» с загрузкой текстового документа. 
в) Запуск программы Calc.exe. 
г) Завершение приложения «Блокнот».

3. Добавьте в приложение ресурсы и код для получения информации состояния дочерних процессов 
 
4. Выполните эксперименты с полученной программой: 
4.1 Создать процесс 1 и просмотреть информацию о нем. Закрыть запущенный Блокнот и просмотреть информацию о процессе 1; 
4.2 Создать процесс 2 и просмотреть информацию о нем. 
4.3 Закрыть Блокнот с текстом файла Test.txt. Посмотреть информацию о процессе 2. Запустить снова процесс 2.
4.4 Создать процесс 3 и просмотреть информацию о нем. 
4.5 Выполнить команду “Закрыть Блокнот” и просмотреть информацию о процессе 
Сравнивать получаемые данные о процессах с информацией программы Process Viewer из пакета инструментальных средств Microsoft Visual Studio и программы «Process Explorer». 

Дать пояснения к полученной информации. Пояснить причину ошибки при выполнении пункта 4.1. 

if (found) {
    // Сброс информации о процессе Блокнота (индекс 1)
    if (ProcHandle[1]) {
        CloseHandle(ProcHandle[1]);  // Закрываем дескриптор
        ProcHandle[1] = NULL;        // Устанавливаем в NULL  
    }
    ProcId[1] = 0;                   // Обнуляем PID   НЕ ПРОИСХОДИТ!
    ThreadId[1] = 0;                 // Обнуляем TID   НЕ ПРОИСХОДИТ!
}
После закрытия Блокнота через функцию FindAndCloseNotepad(), дескриптор процесса ProcHandle[1] закрывается и устанавливается в NULL, но идентификаторы ProcId[1] и ThreadId[1] остаются прежними.

5. Задание по самостоятельной работе: 
5.1 Модифицируйте подпункт б) пункта 2.3 таким образом, чтобы можно было выбирать любой текстовый файл для загрузки в блокнот; 

5.2 Создайте свое приложение с именем TestProc. Добавьте в приложение SP_LB2-1 команду меню TestProc и обеспечте запуск приложения TestProc с возможностью управления размерами, положением и режимом отображения его главного окна (используйте структуру STARTUPINFO в родительском процессе); 
 
5.3 Создайте приложение запускающее блокнот с открытием текстового файла, ожиданием пока пользователь закроет блокнот и последующим выводом содержимого текстового файла. 

https://github.com/Maxevgen555/SP_LB2-1_2-5
При работе использовались ии-агенты https://chat.deepseek.com/  https://www.perplexity.ai/ и copilot (встроенный клиент VS2024, отдельно установленная программа).

Вывод: 

 Я изучил управление процессами в Win32 API, получил практические навыки применения функций Win32 API для управления процессами в Windows-приложении и обеспечения взаимодействия процессов создал приложение, которое обеспечивает создание дочерних процессов c запуском приложений Notepad.exe, Notepad.exe с открытием указанного файла, Calc.exe, собственного приложения. 






Лабораторная работа №2-2 
Вариант №3
Тема: 
 УПРАВЛЕНИЕ ПОТОКАМИ В WIN32 API
Цели лабораторной работы:
 Изучить возможности управление потоками в Win32 API. Приобрести практические навыки создания многопоточных приложений Windows.

Задание:
 	Изучить представленные в папке работы примеры многопоточных приложений и реализованные в них возможности управление потоками в Win32 API. Приобрести практические навыки создания многопоточных приложений Windows.

 Выполнение: 
    	1. В своей рабочей папке создайте проект типа Win32 Application с главным окном, меню и диалоговым окном “О программе …”. Дайте проекту имя “ФАМИЛИЯ_thread_lb” .
 
2. Добавьте PopUp меню “Поток 1” и “Поток 2” с командами “Создать поток”, “Создать ждущий поток”, “Приостановить поток”, “Продолжить работу потока”, “Уничтожить поток”, “Увеличить приоритет”, “Уменьшить приоритет”.
Добавьте PopUp меню “Информация о потоках” с командами “Первичный поток ”, “Поток 1”, “Поток 2”.
 
3. Добавьте в приложение код обработки новых команд меню “Поток 1”, “Поток 2” и "Информация о потоках". Команды в меню “Поток 1”, “Поток 2” одинаковые, но для разных потоков.
3.1 .По команде “Создать поток” создавать вторичный поток, функция которого будет выводить в бесконечном цикле “бегущую” строку “Вторичный поток создал <Фамилия>”. Строку выводить в главное окно начиная с задаваемой позиции. Количество созданных вторичных потоков хранить в глобальной переменной g_uThCount. При создании нового потока сохранять дескриптор потока в массиве hSecThread под соответствующим индексом(0 для первичного, 1 для “Поток 1”, 2 для “Поток 2”). Аналогичным образом сохранять идентификаторы потоков в массиве dwSecThreadId. Перед выполнением команды проверять существование соответствующего потока. 
DWORD WINAPI ThreadFunc1(LPVOID lpParam)
{
    HWND hWnd = (HWND)lpParam;  // Получаем дескриптор главного окна из параметра
    HDC hdc;                    // Контекст устройства для рисования
    RECT rect;                  // Прямоугольник для хранения размеров клиентской области
    TCHAR szMsg[] = _T("Вторичный поток 1 создал Гончаров"); // Текст для отображения

    // Бесконечный цикл потока (завершается принудительно)
    while (TRUE)
    {
        // Проверяем состояние потока - рисуем только если поток активен
        if (threadStates[1] == 1) // Если поток активен
        {
            hdc = GetDC(hWnd);  // Получаем контекст устройства для рисования
            if (hdc)
            {
                GetClientRect(hWnd, &rect);  // Получаем размеры клиентской области окна

                // Очистка предыдущей позиции текста (затираем старый текст)
                SetBkColor(hdc, GetSysColor(COLOR_WINDOW));     // Цвет фона = цвет окна
                SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT)); // Цвет текста = стандартный
                TextOut(hdc, thread1Pos - 1, 50, _T(""), 0);    // Затираем старый текст

                // Вывод нового текста
                SetBkColor(hdc, RGB(255, 255, 0));  // Желтый фон
                SetTextColor(hdc, RGB(0, 0, 255));  // Синий текст
                TextOut(hdc, thread1Pos, 50, szMsg, _tcslen(szMsg));  // Рисуем текст

                ReleaseDC(hWnd, hdc);  // Освобождаем контекст устройства
            }

            thread1Pos += 5;  // Перемещаем позицию текста
            if (thread1Pos > rect.right)  // Если текст ушел за правую границу
                thread1Pos = -300;        // Возвращаем в начало (с запасом для плавности)
        }

        Sleep(100);  // Задержка для контроля скорости движения
    }

    return 0;  // Код завершения (никогда не выполняется из-за бесконечного цикла)
}
 
3.2. По команде “Создать ждущий поток” создать вторичный поток аналогично, как в пункте 3.1, но находящийся сразу после создания в “спящем” состоянии. Поток не создавать если он уже создан по этой же команде меню или по команде "Создать поток"
 
3.3. По команде “Приостановить поток” перевести поток в состояние ожидания (сделать “спящим”).
3.4. По команде “Продолжить работу потока ” перевести поток в рабочее состояние (“разбудить поток”).
3.5. По команде “Уничтожить поток ” завершить работу потока.
3.6. По команде “Увеличить приоритет” увеличить относительный приоритет потока.
3.7. По команде “Уменьшить приоритет” уменьшить относительный приоритет потока.
 
Для меню "Информация о потоках"
3.8. По команде “Информация о потоках” -> “Поток хх” в диалоговом окне в элемент типа список выводить информацию о соответствующем потоке (включая и первичный поток). Для каждого потока выводить:
3.8.1. Идентификатор потока;
3.8.2. Дескриптор потока;
3.8.3. Состояние потока (активное, ожидание, завершен(код завершения));
3.8.4. Относительный приоритет потока;
3.8.5. Время работы потока с момента его создания.
 
 Добавьте в приложение поток, который будет обеспечивать вывод анимированного изображения в соответствии с индивидуальным заданием.
 
Коды программ и краткое описание лабораторных работ на GitHub:
https://github.com/Maxevgen555/SP_LB2-1_2-5
При работе использовались ии-агенты https://chat.deepseek.com/  https://www.perplexity.ai/ и copilot (встроенный клиент VS2024, отдельно установленная программа).





Лабораторная работа №2-3 
Вариант №3
Тема: 
 СИНХРОНИЗАЦИЯ ВЗАИМОДЕЙСТВУЮЩИХ ПОТОКОВ 
В WIN32 API

Цели лабораторной работы:
 	Изучить возможности согласования работы взаимодействующих потоков с целью исключения гонок и обеспечения необходимой последовательности их выполнения, а так же используемые для этой цели системные средства. Приобрести практические навыки синхронизации работы потоков и создания безопасных, с точки зрения многопоточности, приложений Windows.

Задание:
  	Изучить представленные в папке работы примеры многопоточных приложений и реализованные в них возможности синхронизации работы. Разработать собственные безопасные с точки зрения многопоточности приложения в соответствии с индивидуальными заданиями.
Выполнение: 
Получение практических навыков синхронизации потоков: 
1. Используйте проект предыдущей лабораторной работы 2-2. 
2. Добавьте PopUp меню “Синхронизация” с командами “Включить согласование”, “Выключить согласование”. 
  POPUP "&Синхронизация"
    BEGIN
        MENUITEM "Включить согласование", IDM_SYNC_ENABLE
        MENUITEM "Выключить согласование", IDM_SYNC_DISABLE
    END
3. Добавьте в приложение код обработки новых команд меню и средства синхронизации работы в соответствии с индивидуальным заданием 1. 
void EnableSynchronization()
{
    g_synchronizationEnabled = TRUE;  // Установка флага синхронизации

    // Принудительное обновление окна для отображения изменений
    HWND hWnd = FindWindow(szClassName, NULL);
    if (hWnd) InvalidateRect(hWnd, NULL, TRUE);

    // Информационное сообщение пользователю
    MessageBox(NULL, _T("Синхронизация включена\nКаждый поток будет выполнять N шагов атомарно"),
        _T("Синхронизация"), MB_OK | MB_ICONINFORMATION);
}

// Выключение синхронизации потоков
void DisableSynchronization()
{
    g_synchronizationEnabled = FALSE;  // Сброс флага синхронизации

    // Принудительное обновление окна
    HWND hWnd = FindWindow(szClassName, NULL);
    if (hWnd) InvalidateRect(hWnd, NULL, TRUE);

    // Информационное сообщение пользователю
    MessageBox(NULL, _T("Синхронизация выключена\nПотоки работают параллельно"),
        _T("Синхронизация"), MB_OK | MB_ICONINFORMATION);
}
… 
            // Команды синхронизации
        case IDM_SYNC_ENABLE:  // Включить синхронизацию
            EnableSynchronization();
            break;
        case IDM_SYNC_DISABLE:  // Выключить синхронизацию
            DisableSynchronization();
            break;
…
TCHAR syncInfo[256];
 if (g_synchronizationEnabled)  // Если синхронизация включена
 {
     SetTextColor(hdc, RGB(0, 128, 0));  // Зеленый текст
     _stprintf(syncInfo, _T("✓ СИНХРОНИЗАЦИЯ ВКЛЮЧЕНА (Режим К16: N = %d шагов)"),
         4 * _tcslen(g_thread1Text));
 }
 else  // Если синхронизация выключена
 {
     SetTextColor(hdc, RGB(200, 0, 0));  // Красный текст
     _tcscpy(syncInfo, _T("✗ СИНХРОНИЗАЦИЯ ВЫКЛЮЧЕНА (Параллельный режим)"));
 }
 TextOut(hdc, 20, 155, syncInfo, _tcslen(syncInfo));

 // ОТОБРАЖЕНИЕ СЧЕТЧИКОВ ШАГОВ ПОТОКОВ
 SetTextColor(hdc, RGB(0, 0, 128));  // Темно-синий текст
 TCHAR counterInfo[256];
 _stprintf(counterInfo, _T("Поток 1: %d шагов  |  Поток 2: %d шагов  |  Всего: %d шагов"),
     g_stepCounter[1], g_stepCounter[2], g_stepCounter[1] + g_stepCounter[2]);
 TextOut(hdc, 20, 175, counterInfo, _tcslen(counterInfo));

 // ОТОБРАЖЕНИЕ СТАТУСОВ ПОТОКОВ
 SetTextColor(hdc, RGB(80, 80, 80));  // Серый текст
 TCHAR statusInfo[256];
 _stprintf(statusInfo, _T("Статус: Поток1-%s | Поток2-%s | Анимация-%s"),
     hSecThread[1] ? (threadStates[1] == 1 ? _T("Активен") : _T("Приостановлен")) : _T("Не создан"),
     hSecThread[2] ? (threadStates[2] == 1 ? _T("Активен") : _T("Приостановлен")) : _T("Не создан"),
     hAnimationThread ? (animationState == 1 ? _T("Активна") : _T("Приостановлена")) : _T("Не создана"));
 TextOut(hdc, 20, 195, statusInfo, _tcslen(statusInfo));

 // ВОССТАНОВЛЕНИЕ ИСХОДНОГО ШРИФТА И УДАЛЕНИЕ СОЗДАННОГО
 SelectObject(hdc, hOldFont);
 DeleteObject(hFont);

 EndPaint(hWnd, &ps);  // Завершение перерисовки
… 

4. Выполните компиляцию, компоновку и отладку программы. 
5. Выполните тестирование добавленных функций ( работа с синхронизацией и без).  
 
При включении синхронизации потоки выполняются попеременно, заданный промежуток времени.
6. Создайте и протестируйте приложение с применением для синхронизации объекта «ожидающий таймер» (WaitableTimer Object) в соответствии с индивидуальным заданием 2.  	
POPUP "&Таймер"
BEGIN
    MENUITEM "Создать ждущий таймер", IDM_TIMER_CREATE
    MENUITEM "Запустить таймер", IDM_TIMER_START
    MENUITEM "Остановить таймер", IDM_TIMER_STOP
    MENUITEM "Информация о таймере", IDM_TIMER_INFO
END

// Таймер
#define IDM_TIMER_CREATE 1601
#define IDM_TIMER_START 1602
#define IDM_TIMER_STOP 1603
#define IDM_TIMER_INFO 1604

// ==================== ФУНКЦИИ ДЛЯ WAITABLE TIMER (ВАРИАНТ Т3) ====================

// Создание ждущего таймера
void CreateWaitableTimer()
{
    if (hWaitableTimer != NULL)
    {
        MessageBox(NULL, _T("Таймер уже создан!"), _T("Ошибка"), MB_OK | MB_ICONWARNING);
        return;
    }

    // Создание ждущего таймера
    hWaitableTimer = CreateWaitableTimer(NULL, FALSE, NULL);
    if (hWaitableTimer)
    {
        MessageBox(NULL, _T("Ждущий таймер создан успешно!"), _T("Таймер"), MB_OK | MB_ICONINFORMATION);
    }
    else
    {
        MessageBox(NULL, _T("Ошибка создания таймера!"), _T("Ошибка"), MB_OK | MB_ICONERROR);
    }
}

// Запуск таймера
void StartWaitableTimer()
{
    if (hWaitableTimer == NULL)
    {
        MessageBox(NULL, _T("Сначала создайте таймер!"), _T("Ошибка"), MB_OK | MB_ICONWARNING);
        return;
    }

    if (g_timerEnabled)
    {
        MessageBox(NULL, _T("Таймер уже запущен!"), _T("Ошибка"), MB_OK | MB_ICONWARNING);
        return;
    }

    LARGE_INTEGER liDueTime;
    const int nTimerUnitsPerSecond = 10000000; // 100-наносекундные интервалы в секунде

    // Установка времени первого срабатывания: через 15 секунд
    liDueTime.QuadPart = -(15 * nTimerUnitsPerSecond);

    // Установка таймера: первый сигнал через 15 секунд, затем каждые 15 секунд
    if (SetWaitableTimer(hWaitableTimer, &liDueTime, 15 * 1000, NULL, NULL, FALSE))
    {
        g_timerEnabled = TRUE;
        g_timerCounter = 0;

        // Создание потока для обработки таймера
        HANDLE hTimerThread = CreateThread(NULL, 0, TimerThreadProc, NULL, 0, NULL);
        if (hTimerThread)
        {
            CloseHandle(hTimerThread); // Закрываем дескриптор, так как он нам не нужен
        }

        MessageBox(NULL, _T("Таймер запущен!\nКаждые 15 секунд будет появляться MessageBox."), 
                   _T("Таймер"), MB_OK | MB_ICONINFORMATION);
    }
    else
    {
        MessageBox(NULL, _T("Ошибка запуска таймера!"), _T("Ошибка"), MB_OK | MB_ICONERROR);
    }
}

// Остановка таймера
void StopWaitableTimer()
{
    if (hWaitableTimer && g_timerEnabled)
    {
        // Отмена таймера
        CancelWaitableTimer(hWaitableTimer);
        g_timerEnabled = FALSE;
        MessageBox(NULL, _T("Таймер остановлен!"), _T("Таймер"), MB_OK | MB_ICONINFORMATION);
    }
    else
    {
        MessageBox(NULL, _T("Таймер не активен!"), _T("Ошибка"), MB_OK | MB_ICONWARNING);
    }
}

// Функция потока для обработки таймера
DWORD WINAPI TimerThreadProc(LPVOID lpParam)
{
    while (g_timerEnabled)
    {
        // Ожидание сигнала от таймера с таймаутом 15 секунд
        DWORD dwResult = WaitForSingleObject(hWaitableTimer, 15000);

        if (dwResult == WAIT_OBJECT_0) // Таймер сработал
        {
            // Таймер сработал - показываем MessageBox
            ShowTimerMessageBox();
        }
        else if (dwResult == WAIT_TIMEOUT) // Таймаут 15 секунд
        {
            // Если ответ задерживается более 15 секунд - считаем это как RETRY
            g_timerCounter++;
            // Можно добавить логирование или другие действия
        }
        else if (dwResult == WAIT_ABANDONED) // Объект abandoned
        {
            break; // Выход из цикла
        }

        // Проверка флага на каждой итерации
        if (!g_timerEnabled)
            break;
    }
    return 0;
}

// Показать MessageBox с выбором действия
void ShowTimerMessageBox()
{
    g_timerCounter++; // Увеличиваем счетчик вызовов

    // Формирование текста сообщения
    TCHAR message[256];
    _stprintf(message, _T("Вызов номер %d\n\nПродолжить - RETRY\nЗавершить работу - ABORT"), g_timerCounter);

    // Показ MessageBox с таймаутом 15 секунд
    int result = MessageBox(NULL, message, _T("Ждущий таймер Т3"), 
                           MB_ABORTRETRYIGNORE | MB_ICONQUESTION | MB_DEFBUTTON1);

    // Обработка результата
    switch (result)
    {
    case IDABORT: // Завершить работу
        MessageBox(NULL, _T("Работа приложения завершается по запросу пользователя."), 
                   _T("Завершение"), MB_OK | MB_ICONINFORMATION);
        PostQuitMessage(0); // Завершение приложения
        break;

    case IDRETRY: // Продолжить
    case IDIGNORE: // Игнорировать (тоже продолжаем)
        // Просто продолжаем работу
        break;

    default:
        // Любой другой случай (например, закрытие крестиком) - продолжаем
        break;
    }
}
 
Коды программ и краткое описание лабораторных работ на GitHub:
https://github.com/Maxevgen555/SP_LB2-1_2-5
При работе использовались ии-агенты https://chat.deepseek.com/  https://www.perplexity.ai/ и copilot (встроенный клиент VS2024, отдельно установленная программа).

Вывод: 
В ходе выполнения лабораторной работы я изучил возможности согласования работы взаимодействующих потоков с целью исключения гонок и обеспечения необходимой последовательности их выполнения, а так же используемые для этой цели системные средства, представленные в папке работы примеры многопоточных приложений и реализованные в них возможности синхронизации работы. Разработал собственные, безопасные с точки зрения многопоточности, приложения в соответствии с индивидуальными заданиями.

Вывод: 
В ходе выполнения лабораторной работы я изучил возможности управления потоками в Win32 API, приобрел практические навыки создания многопоточных приложений Windows.





Лабораторная работа №2-4 
Вариант №3
Тема: 
 Разработка и применение динамически загружаемых библиотек 
в Win32 приложения

Цели лабораторной работы:
Изучить технологию создания и использования динамически загружаемых библиотек в WIN32 API.
 Выполнение: 

 	 Создать динамически загружаемую библиотеку, экспортирующую функции и глобальные переменные в соответствии с вариантом задания. 
Проект и библиотеку назвать Lb24_<Familia> (в названии проекта присутствует фамилия в латинской транскрипции). 
В функции входа библиотеки (DllMain) предусмотреть для каждой из возможных причин вызова вывод соответствующих сообщений. Например, для причины DLL_PROCESS_ATTACH вывести сообщение вида "Загружается библиотека ИМЯ_МОДУЛЯ. Проект ФАМИЛИЯ_АВТОРА". 
В таблице вариантов заданы прототипы экспортируемых функций. Содержимое каждой из функций предлагается определить самостоятельно. 

; Lb24_Goncharov.def
; Файл определений модуля для управления экспортом из DLL

LIBRARY "Lb24_Goncharov" ; Имя библиотеки

EXPORTS
    ; Список экспортируемых функций
    ; NONAME - экспортировать только по ординалу (без имени)
    Fun31 @1 NONAME ; Функция Fun31 будет доступна только по ординалу 1
    Fun32 @2        ; Функция Fun32 будет доступна по имени и по ординалу 2
    Fun33 @3        ; Функция Fun33 будет доступна по имени и по ординалу 3
    GetDllCallsCount @4
    GetFnCallsCount @5

Глобальная переменная g_nDllCallsCount должна использоваться в качестве счетчика загрузок библиотеки. Ее значение наращивается на единицу всякий раз, когда какой-либо процесс загружает библиотеку (переменная, разделяемая между процессами). 
Глобальная переменная g_nFnCallsCount должна использоваться в качестве счетчика вызова функций библиотеки в отдельном процессе. Ее значение увеличивается клиентской программой - пользователем библиотеки. 
 
3. Создать клиентское приложение ClientLB24Imp с неявным подключением библиотеки. 
Применить технологию неявного подключения библиотеки (Implicit Linking). В приложении выполнить обращение к функциям и переменным 
библиотеки. Обращение к функциям демонстрировать выводом значений аргументов вызова функций, полученного результата и значений глобальных переменных библиотеки (счетчика вызова функций и счетчика загрузок библиотеки). Просмотреть список экспорта библиотеки с помощью DUMPBIN.EXE. 
  
4.Создать клиентское приложение ClientLB24Exp с явным подключением библиотеки. 
Просмотреть список экспорта библиотеки с помощью DUMPBIN.EXE. Добавить в проект библиотеки файл .DEF для запрета декорирования имен и перекомпилировать проект. Просмотреть список экспорта библиотеки с помощью DUMPBIN.EXE. 
Создать клиентское приложение с использованием явного подключения библиотеки (Explicit Linking). В приложении выполнить обращение к функциям и переменным библиотеки. Вывод должен содержать значения аргументов вызова функций, полученный результат и значения глобальных переменных библиотеки (счетчик вызова функций и счетчик загрузок библиотеки в разных процессах). 

Просмотр экспортируемых функций:
 
Просмотр разделяемой секции:
 
Полная информация о DLL вызывается командой 
dumpbin /headers Lb24_Goncharov.dll

5.Выполнить индивидуальное задание. 
int WINAPI Fun31 (double, double) 
float Fun32 (int, int, int) 
void Fun33 (int in, int *out ) 	g_nDllCallsCount 
(разделяемая) 
g_nFnCallsCount 
  	
Задание для самостоятельной работы по теме «Динамически загружаемые библиотеки» :
Создать клиентское приложение для созданной библиотеки, которое будет выполнять обработку текстового файла в соответствии с индивидуальным вариантом. Клиент должен использовать функции библиотеки. После завершения обработки клиент отображает измененный рабочий файл с помощью программы Notepad.
 Варианты задач для самостоятельной работы:  
 3. Подсчитать количество слов в файле и результат в текстовой форме записать в конец файла.
// ClientTextProcessor_Explicit.cpp
#include <windows.h>
#include <iostream>
#include <stdio.h>
#include "../TextProcessor/TextProcessor.h"

// Добавьте эту pragma для явного указания .lib файла
#pragma comment(lib, "TextProcessor.lib")

typedef void(__cdecl* ProcessFileType)(const char*);

int main() {
    SetConsoleOutputCP(1251);
    SetConsoleCP(1251);

    const char* filename = "test.txt";

    printf("Обработка файла '%s'...\n", filename);

    // Явная загрузка DLL
    HINSTANCE hDll = LoadLibraryA("TextProcessor.dll");
    if (!hDll) {
        printf("Ошибка загрузки DLL! Код: %lu\n", GetLastError());
        system("pause");
        return 1;
    }

    // Получаем адрес функции
    ProcessFileType ProcessFile = (ProcessFileType)GetProcAddress(hDll, "ProcessFileAndAppendWordCount");
    if (!ProcessFile) {
        printf("Функция не найдена! Код: %lu\n", GetLastError());
        FreeLibrary(hDll);
        system("pause");
        return 1;
    }

    // Вызываем функцию
    ProcessFile(filename);

    printf("Обработка завершена. Результат записан в конец файла.\n");

    // Запускаем Блокнот
    HINSTANCE result = ShellExecuteA(NULL, "open", "notepad.exe", filename, NULL, SW_SHOWNORMAL);

    FreeLibrary(hDll);
    system("pause");
    return 0;
}
 
Просмотр экспортируемых функций:
 
Коды программ и краткое описание лабораторных работ на GitHub:
https://github.com/Maxevgen555/SP_LB2-1_2-5
При работе использовались ии-агенты https://chat.deepseek.com/  https://www.perplexity.ai/ и copilot (встроенный клиент VS2024, отдельно установленная программа).

Вывод: 
В ходе выполнения лабораторной работы я изучил технологию создания и использования динамически загружаемых библиотек в WIN32 API, создал динамически загружаемую библиотеку, экспортирующую функции и глобальные переменные в соответствии с вариантом задания, клиентское приложение ClientLB24Imp с неявным подключением библиотеки, клиентское приложение ClientLB24Exp с явным подключением библиотеки, индивидуальное задание.






Лабораторная работа №2-5

Вариант №3
Тема: 
 Управление памятью в Win32 API. Проецирование файлов данных на виртуальное адресное пространство
Цели лабораторной работы:
– использование механизма проецирования файлов для .EXE и .DLL модулей; 
– использование механизма проецирования для доступа к файлам данных. 
– организация межпроцессного обмена данными с использованием проецирования данных на виртуальное адресное пространство. 

 Задание 
1. Изучить механизм проецирования файлов на виртуальное адресное пространство процесса в Win32 API и работу приложения-примера FileRev. Преобразовать приложение FileRev в приложение с графическим интерфейсом. Заменить реверс строки на обработку файла в соответствии с индивидуальным заданием. 
2. Изучить механизм обмена данными между процессами через общую проекцию данных. Изучить приложение MMFShare и модифицировать (Добавить в это приложение кнопки “Чтение” и “Запись”).
 Выполнение: 
1.1. Изучите теорию вопроса; 
1.2. Откройте в MSVS проект FileRev, изучите текст приложения, откомпилируйте и запустите его на выполнение. Для выполнения приложения необходимо иметь произвольный текстовый файл. Скопируйте какой-либо текстовый файл в директорию приложения и переименуйте, например, в Test.txt. Приложение FileRev запускается из командной строки. Для запуска выберите команду "Пуск->Выполнить". В открывшемся диалоговом окне введите спецификацию выполняемого файла и, через пробел, спецификацию тестового файла данных в качестве параметра командной строки. 
1.3. Разработайте приложение с графическим интерфейсом, которое будет выполнять задачу, представленную в пункте 1.2. Шаги создания объекта “файл”, объекта “проецируемый файл”, отображения на адресное пространство, закрытия отображения, закрытия дескрипторов объектов ядра выполнять по соответствующим командам меню. Для самостоятельной работы: вместо реверса текстовой строки выполнить обработку по индивидуальному заданию и вывести результаты на экран. 
Задания для самостоятельной работы к п.1.2 
3. Подсчитать количество слов в файле и результат в текстовой форме записать в конец файла.
Выполненные действия:
1.	Преобразование в GUI-приложение
o	Создано диалоговое окно с элементами управления
o	Реализован выбор файла через стандартный диалог
o	Добавлены кнопки "Обзор" и "Обработать"
2.	Реализация обработки файла
o	Использован механизм Memory-Mapped Files
o	Разработана функция подсчета слов в файле
o	Реализовано добавление результатов в конец файла
o	Организован автоматический запуск Блокнота для просмотра результатов
3.	Ключевые особенности
o	Обработка файлов любого размера
o	Корректное освобождение ресурсов
o	Обработка ошибок с выводом диагностики

2.1. Изучите теорию вопроса. 
2.2. Откройте в MSVS проект MMFShare , изучите текст приложения, откомпилируйте и запустите его на выполнение. 
2.3. Модифицируйте приложение таким образом, чтобы при старте программы она сразу же создавала именованный file-mapping объект через вызов CreateFileMapping и создавала окно просмотра (MapViewOfFile) . Добавить в это приложение кнопки “Чтение” и “Запись”. При нажатии кнопки “Запись” текс из поля Edit переписывается в окно просмотра проекции. По кнопке “Чтение” текст из окна просмотра проекции копируется в поле Edit. 
2.4. Запустите на выполнение несколько экземпляров приложения и проведите эксперимент по обмену данными между процессами. 
Выполненные действия:
1.	Автоматическое создание проекции
o	Объект проецируемого файла создается при запуске приложения
o	Реализовано автоматическое подключение к существующей области памяти
2.	Добавление функциональности
o	Добавлены кнопки "Запись" и "Чтение"
o	Реализован механизм межпроцессного обмена данными
o	Обеспечена возможность многократного создания/закрытия проекций
3.	Тестирование межпроцессного взаимодействия
o	Запущено несколько экземпляров приложения
o	Проверена передача данных между процессами
o	Протестирована работа с общей областью памяти

Почему "Открыть и прочитать" отключена:
В оригинальном MMFShare эта кнопка использовалась для:
•	Открытия существующего именованного объекта проекции
•	Чтения данных из него
В нашей модифицированной версии эта функциональность автоматически выполняется при запуске приложения через функцию CreateMapping(), которая:
1.	Пытается создать новый объект
2.	Если объект уже существует - подключается к нему
3.	Автоматически проецирует данные в память

Коды программ и краткое описание лабораторных работ на GitHub:
https://github.com/Maxevgen555/SP_LB2-1_2-5
При работе использовались ии-агенты https://chat.deepseek.com/  https://www.perplexity.ai/ и copilot (встроенный клиент VS2024, отдельно установленная программа).

Вывод: 
В ходе выполнения лабораторной работы я изучил использование механизма проецирования файлов для .EXE и .DLL модулей, использование механизма проецирования для доступа к файлам данных, организация межпроцессного обмена данными с использованием проецирования данных на виртуальное адресное пространство. Лабораторная работа продемонстрировала эффективность использования механизма проецирования файлов в память для работы с большими файлами и организации межпроцессного взаимодействия в Windows-приложениях.



